import 'package:cloud_firestore/cloud_firestore.dart';
import '../../domain/entities/user_preference.dart';
import '../../../admin/domain/entities/news.dart';
import '../services/gemini_recommendation_service.dart';
import '../models/smart_notification_model.dart';
import '../../domain/entities/smart_notification.dart';
import '../datasources/notification_datasource.dart';

/// Service t·ª± ƒë·ªông t·∫°o th√¥ng b√°o khi c√≥ tin m·ªõi
class AutoNotificationService {
  final FirebaseFirestore firestore;
  final NotificationDataSource notificationDataSource;
  final GeminiRecommendationService geminiService;

  AutoNotificationService({
    required this.firestore,
    required this.notificationDataSource,
    required this.geminiService,
  });

  /// T·ª± ƒë·ªông check tin m·ªõi v√† t·∫°o notification cho user
  Future<void> checkAndCreateNotifications(
    String userId,
    UserPreference userPreference,
  ) async {
    try {
      // L·∫•y th·ªùi gian check l·∫ßn cu·ªëi (24h tr∆∞·ªõc)
      final yesterday = DateTime.now().subtract(const Duration(hours: 24));
      
      // Check daily limit
      final todaySent = await notificationDataSource.getTodaySentCount(userId);
      if (todaySent >= userPreference.dailyNotificationLimit) {
        print('Daily notification limit reached: $todaySent/${userPreference.dailyNotificationLimit}');
        return;
      }

      // L·∫•y tin m·ªõi trong 24h - tƒÉng l√™n 50 tin
      final newsSnapshot = await firestore
          .collection('news')
          .where('createdAt', isGreaterThan: yesterday.toIso8601String())
          .orderBy('createdAt', descending: true)
          .limit(50)
          .get();

      if (newsSnapshot.docs.isEmpty) {
        print('No new news in last 24 hours');
        return;
      }

      // Convert to News entities
      final newsList = newsSnapshot.docs.map((doc) {
        final data = doc.data();
        return News(
          id: doc.id,
          title: data['title'] ?? '',
          content: data['content'] ?? '',
          imageUrls: List<String>.from(data['imageUrls'] ?? []),
          category: data['category'] ?? '',
          source: data['source'] ?? '',
          createdAt: DateTime.parse(data['createdAt'] ?? DateTime.now().toIso8601String()),
        );
      }).toList();

      print('Found ${newsList.length} new articles');

      // L·ªçc v√† t·∫°o notification cho t·ª´ng tin
      int notificationsCreated = 0;
      for (final news in newsList) {
        // Check if already sent notification for this news
        final existingNotif = await firestore
            .collection('users')
            .doc(userId)
            .collection('notifications')
            .where('newsId', isEqualTo: news.id)
            .limit(1)
            .get();

        if (existingNotif.docs.isNotEmpty) {
          continue; // Skip if already notified
        }

        // Check daily limit again
        if (todaySent + notificationsCreated >= userPreference.dailyNotificationLimit) {
          print('Reached daily limit during processing');
          break;
        }

        // Calculate AI relevance score
        final relevanceScore = await geminiService.calculateRelevanceScore(
          news: news,
          userPreference: userPreference,
        );

        // Gi·∫£m threshold xu·ªëng 0.3 ƒë·ªÉ d·ªÖ test (g·ªëc: 0.5)
        if (relevanceScore < 0.3) {
          print('Skip ${news.title.substring(0, 30)}... - Low score: $relevanceScore');
          continue;
        }

        // Generate personalized body
        final personalizedBody = await geminiService.generatePersonalizedNotificationBody(
          news: news,
          userPreference: userPreference,
        );

        // Determine priority and type
        final priority = relevanceScore >= 0.8
            ? NotificationPriority.high
            : relevanceScore >= 0.6
                ? NotificationPriority.normal
                : NotificationPriority.low;

        final type = news.category == 'Kh·∫©n c·∫•p'
            ? NotificationType.breaking
            : NotificationType.recommended;

        // Create notification
        final notification = SmartNotificationModel(
          id: 'auto_${DateTime.now().millisecondsSinceEpoch}_${news.id}',
          userId: userId,
          newsId: news.id,
          title: news.title,
          body: personalizedBody,
          type: type,
          priority: priority,
          aiRelevanceScore: relevanceScore,
          scheduledAt: DateTime.now(),
          sentAt: DateTime.now(),
          isRead: false,
          metadata: {
            'category': news.category,
            'source': news.source,
            'autoGenerated': true,
          },
        );

        // Save to Firestore
        await notificationDataSource.saveNotification(notification);

        // Show real push notification immediately with newsId payload
        await notificationDataSource.showLocalNotification(
          title: notification.title,
          body: notification.body,
          payload: {'newsId': news.id},
        );
        
        // Send FCM push notification if user has token
        await _sendFCMNotification(userId, notification);

        notificationsCreated++;
        print('‚úÖ Created notification for: ${news.title.substring(0, 30)}... (score: ${relevanceScore.toStringAsFixed(2)})');

        // Delay ƒë·ªÉ tr√°nh spam
        await Future.delayed(const Duration(milliseconds: 500));
      }

      print('Auto notification completed: $notificationsCreated notifications created');
    } catch (e) {
      print('Error in auto notification: $e');
    }
  }
  
  /// Send FCM push notification to user's device
  Future<void> _sendFCMNotification(String userId, SmartNotificationModel notification) async {
    try {
      // Get user's FCM token
      final userDoc = await firestore.collection('users').doc(userId).get();
      final fcmToken = userDoc.data()?['fcmToken'] as String?;
      
      if (fcmToken == null) {
        print('‚ö†Ô∏è No FCM token for user: $userId');
        return;
      }
      
      // This would typically be done from your backend/Firebase Functions
      // For demo, we'll just log it with newsId data
      print('üì® Would send FCM to token: ${fcmToken.substring(0, 20)}...');
      print('üì® Title: ${notification.title}');
      print('üì® Body: ${notification.body}');
      print('üì® Data: {newsId: ${notification.newsId}}');
      
      // Note: In production, use Firebase Admin SDK from backend to send FCM
      // with data payload: {'newsId': notification.newsId}
      // Example: message.data = {'newsId': notification.newsId}
      
    } catch (e) {
      print('Error sending FCM: $e');
    }
  }

  /// Check tin breaking news (kh·∫©n c·∫•p) - g·ª≠i ngay l·∫≠p t·ª©c
  Future<void> checkBreakingNews(String userId) async {
    try {
      // L·∫•y tin breaking news trong 1 gi·ªù qua
      final oneHourAgo = DateTime.now().subtract(const Duration(hours: 1));
      
      final breakingNews = await firestore
          .collection('news')
          .where('category', isEqualTo: 'Kh·∫©n c·∫•p')
          .where('createdAt', isGreaterThan: oneHourAgo.toIso8601String())
          .orderBy('createdAt', descending: true)
          .limit(5)
          .get();

      for (final doc in breakingNews.docs) {
        final data = doc.data();
        
        // Check if already notified
        final existingNotif = await firestore
            .collection('users')
            .doc(userId)
            .collection('notifications')
            .where('newsId', isEqualTo: doc.id)
            .limit(1)
            .get();

        if (existingNotif.docs.isNotEmpty) continue;

        // Create breaking news notification
        final notification = SmartNotificationModel(
          id: 'breaking_${DateTime.now().millisecondsSinceEpoch}_${doc.id}',
          userId: userId,
          newsId: doc.id,
          title: '‚ö° ${data['title']}',
          body: data['content']?.toString().substring(0, 100) ?? '',
          type: NotificationType.breaking,
          priority: NotificationPriority.high,
          aiRelevanceScore: 1.0,
          scheduledAt: DateTime.now(),
          sentAt: DateTime.now(),
          isRead: false,
          metadata: {'category': 'Kh·∫©n c·∫•p', 'breaking': true},
        );

        await notificationDataSource.saveNotification(notification);
        
        // Show immediate notification for breaking news with newsId payload
        await notificationDataSource.showLocalNotification(
          title: notification.title,
          body: notification.body,
          payload: {'newsId': doc.id},
        );
        
        // Send FCM push notification
        await _sendFCMNotification(userId, notification);

        print('‚ö° Breaking news notification sent: ${data['title']}');
      }
    } catch (e) {
      print('Error checking breaking news: $e');
    }
  }
}
