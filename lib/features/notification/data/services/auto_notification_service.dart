import 'package:cloud_firestore/cloud_firestore.dart';
import '../../domain/entities/user_preference.dart';
import '../../../admin/domain/entities/news.dart';
import '../services/gemini_recommendation_service.dart';
import '../models/smart_notification_model.dart';
import '../../domain/entities/smart_notification.dart';
import '../datasources/notification_datasource.dart';

/// Service tự động tạo thông báo khi có tin mới
class AutoNotificationService {
  final FirebaseFirestore firestore;
  final NotificationDataSource notificationDataSource;
  final GeminiRecommendationService geminiService;

  AutoNotificationService({
    required this.firestore,
    required this.notificationDataSource,
    required this.geminiService,
  });

  /// Tự động check tin mới và tạo notification cho user
  Future<void> checkAndCreateNotifications(
    String userId,
    UserPreference userPreference,
  ) async {
    try {
      // Lấy thời gian check lần cuối (24h trước)
      final yesterday = DateTime.now().subtract(const Duration(hours: 24));
      
      // Check daily limit
      final todaySent = await notificationDataSource.getTodaySentCount(userId);
      if (todaySent >= userPreference.dailyNotificationLimit) {
        print('Daily notification limit reached: $todaySent/${userPreference.dailyNotificationLimit}');
        return;
      }

      // Lấy tin mới trong 24h - tăng lên 50 tin
      final newsSnapshot = await firestore
          .collection('news')
          .where('createdAt', isGreaterThan: yesterday.toIso8601String())
          .orderBy('createdAt', descending: true)
          .limit(50)
          .get();

      if (newsSnapshot.docs.isEmpty) {
        print('No new news in last 24 hours');
        return;
      }

      // Convert to News entities
      final newsList = newsSnapshot.docs.map((doc) {
        final data = doc.data();
        return News(
          id: doc.id,
          title: data['title'] ?? '',
          content: data['content'] ?? '',
          imageUrls: List<String>.from(data['imageUrls'] ?? []),
          category: data['category'] ?? '',
          source: data['source'] ?? '',
          createdAt: DateTime.parse(data['createdAt'] ?? DateTime.now().toIso8601String()),
        );
      }).toList();

      print('Found ${newsList.length} new articles');

      // Lọc và tạo notification cho từng tin
      int notificationsCreated = 0;
      for (final news in newsList) {
        // Check if already sent notification for this news
        final existingNotif = await firestore
            .collection('users')
            .doc(userId)
            .collection('notifications')
            .where('newsId', isEqualTo: news.id)
            .limit(1)
            .get();

        if (existingNotif.docs.isNotEmpty) {
          continue; // Skip if already notified
        }

        // Check daily limit again
        if (todaySent + notificationsCreated >= userPreference.dailyNotificationLimit) {
          print('Reached daily limit during processing');
          break;
        }

        // Calculate AI relevance score
        final relevanceScore = await geminiService.calculateRelevanceScore(
          news: news,
          userPreference: userPreference,
        );

        // Chỉ gửi notification nếu score >= 0.5 (tránh spam)
        if (relevanceScore < 0.5) {
          print('Skip ${news.title.substring(0, 30)}... - Low score: $relevanceScore');
          continue;
        }

        // Generate personalized body
        final personalizedBody = await geminiService.generatePersonalizedNotificationBody(
          news: news,
          userPreference: userPreference,
        );

        // Determine priority and type
        final priority = relevanceScore >= 0.8
            ? NotificationPriority.high
            : relevanceScore >= 0.6
                ? NotificationPriority.normal
                : NotificationPriority.low;

        final type = news.category == 'Khẩn cấp'
            ? NotificationType.breaking
            : NotificationType.recommended;

        // Create notification
        final notification = SmartNotificationModel(
          id: 'auto_${DateTime.now().millisecondsSinceEpoch}_${news.id}',
          userId: userId,
          newsId: news.id,
          title: news.title,
          body: personalizedBody,
          type: type,
          priority: priority,
          aiRelevanceScore: relevanceScore,
          scheduledAt: DateTime.now(),
          sentAt: DateTime.now(),
          isRead: false,
          metadata: {
            'category': news.category,
            'source': news.source,
            'autoGenerated': true,
          },
        );

        // Save to Firestore
        await notificationDataSource.saveNotification(notification);

        // Show local notification (không popup web, chỉ lưu)
        // Nếu muốn popup thì uncomment dòng dưới
        // await notificationDataSource.showLocalNotification(
        //   title: notification.title,
        //   body: notification.body,
        // );

        notificationsCreated++;
        print('✅ Created notification for: ${news.title.substring(0, 30)}... (score: ${relevanceScore.toStringAsFixed(2)})');

        // Delay để tránh spam
        await Future.delayed(const Duration(milliseconds: 500));
      }

      print('Auto notification completed: $notificationsCreated notifications created');
    } catch (e) {
      print('Error in auto notification service: $e');
    }
  }

  /// Check tin breaking news (khẩn cấp) - gửi ngay lập tức
  Future<void> checkBreakingNews(String userId) async {
    try {
      // Lấy tin breaking news trong 1 giờ qua
      final oneHourAgo = DateTime.now().subtract(const Duration(hours: 1));
      
      final breakingNews = await firestore
          .collection('news')
          .where('category', isEqualTo: 'Khẩn cấp')
          .where('createdAt', isGreaterThan: oneHourAgo.toIso8601String())
          .orderBy('createdAt', descending: true)
          .limit(5)
          .get();

      for (final doc in breakingNews.docs) {
        final data = doc.data();
        
        // Check if already notified
        final existingNotif = await firestore
            .collection('users')
            .doc(userId)
            .collection('notifications')
            .where('newsId', isEqualTo: doc.id)
            .limit(1)
            .get();

        if (existingNotif.docs.isNotEmpty) continue;

        // Create breaking news notification
        final notification = SmartNotificationModel(
          id: 'breaking_${DateTime.now().millisecondsSinceEpoch}_${doc.id}',
          userId: userId,
          newsId: doc.id,
          title: '⚡ ${data['title']}',
          body: data['content']?.toString().substring(0, 100) ?? '',
          type: NotificationType.breaking,
          priority: NotificationPriority.high,
          aiRelevanceScore: 1.0,
          scheduledAt: DateTime.now(),
          sentAt: DateTime.now(),
          isRead: false,
          metadata: {'category': 'Khẩn cấp', 'breaking': true},
        );

        await notificationDataSource.saveNotification(notification);
        
        // Show popup for breaking news
        await notificationDataSource.showLocalNotification(
          title: notification.title,
          body: notification.body,
        );

        print('⚡ Breaking news notification sent: ${data['title']}');
      }
    } catch (e) {
      print('Error checking breaking news: $e');
    }
  }
}
